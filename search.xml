<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python Tutorial 读后感（二）：命名空间和作用域]]></title>
    <url>%2FPython-Tutorial-%E8%AF%BB%E5%90%8E%E6%84%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[注意：内容基于 Python 3.6 命名空间 A namespace is a mapping from names to objects. 命名空间，直译是名称到对象（比如数字、字符串等）的映射，（我的理解是）这些名称构成一个命名空间。一般有三种命名空间 内置名称（ built-in names ）， Python 语言内置的名称，比如函数名 abs 、 char 和异常名称 BaseException 、 Exception 等等。 全局名称（ global names ），模块中定义的名称。 局部名称（ local names ），函数中定义的名称。（类中定义的也是） 看个例子就清楚了12345678910class A(object): # A 是全局名称， object 是内置名称 a = -1 # a 是局部名称（类中） # print_abs_a 是局部名称（类中）， self 是局部名称（函数中） def print_abs_a(self): # temp_str 是局部名称（函数中）， abs 是内置名称 temp_str = '%s 的绝对值是 %s' % (self.a, abs(self.a)) print(temp_str) # print 是内置名称t = A() # t 是全局名称 命名空间的生命周期各不相同 内置命名空间在编译器启动开始建立，直到程序结束 全局命名空间，在模块文件读入后建立，直到程序结束。 局部命名空间，在函数被调用后建立，函数退出时结束。递归函数每次调用都会建立不同的命名空间。对于类来说类似，实例化后建立，实例销毁后结束。 作用域 A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace. 作用域，是 Python 代码中的一段文本区域，在这个区域里能「直接」访问一个命名空间中的名称。所谓「直接」，就是只要给出名称（如 some_name ）就能找到命名空间中的对应的名称，而不需要使用类似 modulename.subname 或是 object.attribute 等这样的方式。 有四种作用域： local scope ，最内层，包含 local names ，（搜索名称时）最先被搜索 nonlocal scope, 如果一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal global scope ，包含 global names builtin scope, 包含 built-in names ，最后被搜索 其中，需要强调的是 local scope 和 nonlocal scope 是一个相对的概念。如果一个模块中，函数 A 直接包含了函数 B ， B 又直接包含了函数 C 。如果以 C 中的名称作为参考，那么 C 中的作用域为 local scope ，则 B 中的作用域就为 nonlocal scope 。如果以 B 中的名称作为参考，那么 B 中的作用域是 local scope ， 则 A 中的作用域为 nonlocal 。如果以 A 中的名称作为参考，那么 A 中的作用域是 local scope ，不过要注意，模块中的作用域始终为 global scope ，这时并没有 nonlocal scope。 对于赋值操作，默认都是操作当前作用域中包含的名称。假设现在在 local scope ，如果要对 nonlocal scope 包含的名称进行赋值，则要用 nonlocal 关键字。如果要对 global scope 中包含的名称赋值要用 global 关键字。需要注意的是，如果在某个作用域内没有对应的名称，则在对应的作用域中会新增。下面的例子可以帮你理解赋值操作 123456789101112131415161718192021222324# 来自 https://docs.python.org/3/tutorial/classes.html#scopes-and-namespaces-exampledef scope_test(): def do_local(): spam = "local spam" def do_nonlocal(): nonlocal spam spam = "nonlocal spam" def do_global(): global spam spam = "global spam" spam = "test spam" do_local() print("After local assignment:", spam) do_nonlocal() print("After nonlocal assignment:", spam) do_global() print("After global assignment:", spam)scope_test()print("In global scope:", spam) 输出为1234After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam 对应读值操作，都是由内到外进行搜索。即 local scope -&gt; nonlocal scope -&gt; global scope -&gt; builtin scope ，如果都找不到对应的名称，则报错。123456789101112131415&gt;&gt;&gt; x = 1&gt;&gt;&gt; def t():... def tt():... print(x)... tt()...&gt;&gt;&gt; t()1&gt;&gt;&gt; del x&gt;&gt;&gt; t()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 4, in t File "&lt;stdin&gt;", line 3, in ttNameError: name 'x' is not defined 如果要读取指定作用域的名称，则可以使用对应的 nonlocal 或 global 关键字，如果对应作用域找不到该名称，则直接报错。1234567891011121314151617&gt;&gt;&gt; x = 1&gt;&gt;&gt; def t():... x = 2... def tt():... global x... print(x)... tt()...&gt;&gt;&gt; t()1&gt;&gt;&gt; del x&gt;&gt;&gt; t()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 6, in t File "&lt;stdin&gt;", line 5, in ttNameError: name 'x' is not defined 当然，如果当前作用域已有同名的名称，就不能使用这 nonlocal 或 global 了，否则会报错。1234567&gt;&gt;&gt; x = 1&gt;&gt;&gt; def t():... x = 2... global x... File "&lt;stdin&gt;", line 3SyntaxError: name 'x' is assigned to before global declaration 同时发现个有趣的地方123456789101112131415161718192021&gt;&gt;&gt; def t():... def tt():... nonlocal x... print(x)... tt()... File "&lt;stdin&gt;", line 3SyntaxError: no binding for nonlocal 'x' found&gt;&gt;&gt; def t():... def tt():... global x... print(x)... tt()...&gt;&gt;&gt; t()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 5, in t File "&lt;stdin&gt;", line 4, in ttNameError: name 'x' is not defined 第一个报的是语法错误，而第二个是运行时报的错误。这说明了一个问题：局部名称的查找是编译时就确定的，而全局名称和内置名称的查找都是在运行时确定的。（这里只是指出来，了解下就行，暂时没必要深入） 小结个人觉得，没必要太在意命名空间和作用域的定义，之所以有命名空间的说法，只是为了引入作用域的概念。我们只需要清楚两个方面的内容：一是，哪个作用域包含哪些名称；二是，相反的，赋值和读值的时候它又是指向哪个作用域，并理解 nonlocal 和 global 的使用。 个人理解可能比较局限，不当之处还望指正]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Tutorial 读后感（一）：序列类型以及函数参数类型]]></title>
    <url>%2FPython-Tutorial-%E8%AF%BB%E5%90%8E%E6%84%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言我学习上有个不好的习惯，每次碰到一个新的技术，总是漫天找教程，找出几份还要对比下哪个比较好，然后才打算看。有时候找着找着半天时间过去了，对要学的新东西却还没开始接触，仿佛找资源倒成了目的一样。这样浪费了大把时间，找出来的很多时候还只看一点点。而且，其实基础教程都差不多，大可不必这样。现在，索性直接看官方文档，虽说英语不怎么好，但是长痛不如短痛，反正以后都要接触的。我从 Python Tutorial 部分切入，有时会有一些新的理解，想找个地方记录一下，所以就有了这个系列的文章。好了，不说废话了，进入正题。 注意：内容基于 Python 3.6.3 序列类型（ Sequence Type ）我们先来看个例子1234567&gt;&gt;&gt; x, y, z = [1, 2, 3]&gt;&gt;&gt; x1&gt;&gt;&gt; y2&gt;&gt;&gt; z3 上面的操作叫做「多重赋值」，其实，只要是「序列类型」的，都可以有这种操作。序列类型包括这几种： 列表（ list ）、元组（ tuple ）、 range 、 str、 binary sequence type12345&gt;&gt;&gt; [1, 2, 3] # 列表&gt;&gt;&gt; (1, 3, 3) # 元祖&gt;&gt;&gt; range(1, 4) # range&gt;&gt;&gt; 'text string: 文本字符串' # str&gt;&gt;&gt; b'abc' # byte ( binary sequence type 的一种，这里了解就行) 所以，我们后面看到下面的用法就不奇怪了12345&gt;&gt;&gt; x, y = '你好'&gt;&gt;&gt; x'你'&gt;&gt;&gt; y'好' 这个也好理解1234&gt;&gt;&gt; 'abc' &gt; 'aac' # 字典序比较True&gt;&gt;&gt; ['a', 'b', 'c'] &gt; ['a', 'a', 'c'] # 同上True 当然，「序列类型」还有很多类似的操作1234567891011121314&gt;&gt;&gt; 1 in [1, 2, 3] # x in sTrue&gt;&gt;&gt; 'a' in 'abc'True&gt;&gt;&gt; [1] * 5 # s * n[1, 1, 1, 1, 1]&gt;&gt;&gt; 'a' * 3'aaa'&gt;&gt;&gt; len([1, 2, 3]) # len(s)3&gt;&gt;&gt; len('abc')3&gt;&gt;&gt; # 等等... 函数参数类型共有三种：位置参数（ Positional Arguments ）、可变参数（ Arbitrary Arguments ）、关键字参数（ Keyword Arguments ）先有个整体的认识。函数定义如下123456789def introduce(name, *hobbies, **extra_info): print('Name:') print(name) print('Hobbies:') for hobby in hobbies: print(hobby) print('Extra info:') for key in extra_info: print(key, ':', extra_info[key]) 调用123introduce('xiaoming', 'movie', 'game', age=22, address='cn') 输出如下12345678Name:xiaomingHobbies:moviegameExtra info:age : 22address : cn 其中， name 为「位置参数」， *hobbies 为「可变参数」， **extra_info为「关键字参数」「位置参数」是指函数调用时根据参数位置进行赋值。12345678910111213141516171819202122232425&gt;&gt;&gt; def f(arg1, arg2): # arg1 ， arg2 为「位置参数」... print(arg1, arg2)...&gt;&gt;&gt; f(1, 2) # 实参 1 对应形参 arg1 ，所以 arg1 = 1 。arg2 类似1 2&gt;&gt;&gt; f(1) # 少参数会报错Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: f() missing 1 required positional argument: 'arg2'&gt;&gt;&gt; f(1, 2, 3) # 多参数也会报错Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 3 were given&gt;&gt;&gt;&gt;&gt;&gt; # 但这可以通过设置参数默认值解决...&gt;&gt;&gt; def f(arg1, arg2=2, arg3=3):... print(arg1, arg2, arg3)...&gt;&gt;&gt; f(1)1 2 3&gt;&gt;&gt; f(1, 3)1 3 3&gt;&gt;&gt; f(1, 3, 5)1 3 5 「可变参数」，个人理解就是用来解决不确定参数的问题的12345&gt;&gt;&gt; def my_join(sep, *args):... return sep.join(args)...&gt;&gt;&gt; my_join(', ', 'apple', 'pear')'apple, pear' args 是一个元组，函数调用时，除掉「位置参数」用掉的参数，剩下的都会按顺序放到这个元组。 「关键字参数」是指以 keyword=value 形式定义的参数12345678910111213141516171819202122232425262728293031323334353637&gt;&gt;&gt; def f(name, age=22, address='cn'):... print('name:', name)... print('age:', age)... print('address:', address)...&gt;&gt;&gt; f('xiaoming') # 只传一个参数name: xiaomingage: 22address: cn&gt;&gt;&gt; f('xm', age=23, address='us') # 两个都传name: xmage: 23address: us&gt;&gt;&gt; f('xm', address='us', age=23) # 顺序可以随意name: xmage: 23address: us&gt;&gt;&gt; f('xm', age=23, address='us', height='175cm') # 多了会出问题Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: f() got an unexpected keyword argument 'height'&gt;&gt;&gt; # 但可以这样解决...&gt;&gt;&gt; def f(name, age=22, address='cn', **extra_info):... print('name:', name)... print('age:', age)... print('address:', address)... print('extra_info:')... for kw in extra_info:... print(kw, ':', extra_info[kw])...&gt;&gt;&gt; f('xm', age=23, address='us', height='175cm') # 搞定name: xmage: 23address: usextra_info:height : 175cm extra_info 是一个字典，由与前面参数对应不上的「关键字参数」组成。 相信很多朋友看到这，都有点疑惑，这「位置参数」和「关键字参数」怎么区分呢？我的理解是不用区分。理由如下12345678910111213&gt;&gt;&gt; def f(name, age=22, address='cn'):... print('name:', name)... print('age:', age)... print('address:', address)...&gt;&gt;&gt; f() # 不传参会报错， name 像是一个「位置参数」Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: f() missing 1 required positional argument: 'name'&gt;&gt;&gt; f(age=23, address='us', name='xm') # name 当作「关键字参数」也没问题name: xmage: 23address: us 「位置参数」和「关键字参数」是一个相对的概念，不用去死磕。有的把三个参数都当作「位置参数」，有的把三个参数都当作「关键字参数」，有的把第一个当作「位置参数」，后面两个当作「关键字参数」。理解上其实都没问题，我们只要明白在各种情况下如何使用就好。（不过我个人倾向于最后一种理解） 另外需要注意下相关的两个操作1234567891011&gt;&gt;&gt; def f(arg1, arg2, arg3):... print(arg1, arg2, arg3)...&gt;&gt;&gt; # *s 相当于 s 中的元素解包，然后按顺序放到参数列表（ s 可以是「序列类型」中的一种）...&gt;&gt;&gt; f(*[1, 3, 5]) # 等同 f(1, 2, 3)1 3 5&gt;&gt;&gt; # **d 相当于把 d 中的键值对解包，然后放到参数列表 ( d 可以是「字典」)...&gt;&gt;&gt; f(**&#123;'arg1': 2, 'arg2': 4, 'arg3': 6&#125;) # 等同 f(arg1=2, arg2=4, arg3=6)2 4 6 最后来个总结，放出本小节的第一个函数定义12def introduce(name, *hobbies, **extra_info): pass 当「位置参数」、「可变参数」和「关键字参数」同时存在时，「可变参数」在「关键字参数」之前，「位置参数」在最前。「位置参数」和「关键字参数」没必要强行去区分，有自己的合理理解即可。还有就是理解函数调用时， * 可以用于解包「列表」（或其它「序列类型」）， ** 可以用于解包「字典」。 个人理解可能比较局限，不当之处还望指正]]></content>
      <categories>
        <category>语言学习</category>
      </categories>
  </entry>
</search>
